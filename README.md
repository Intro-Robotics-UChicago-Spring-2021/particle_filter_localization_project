# particle_filter_localization_project
## Implementation Plan
### Name of team members
* Jingyu Cai
* Tianle Liu
### Implementation
* `initialize_particle_cloud()`: We will initialize the particle cloud with random locations and orientations throughout the map and populate the `particle_cloud` array with `Particle` elements. To test it, we will physically display the poses of the elements in the `particle_cloud` array within the map to visualize the distribution of the particles.
* `update_particles_with_motion_model()`: We will calculate how much the robot has moved using its current odometry data and its old odometry data from its last motion update, and move all of the particles with the same amount. To test it, we will test a few individual examples by directly printing out the array to see if the values match our expectations as well as update the display of the `particle_cloud` array to visualize if the movement of the particles correspond to the movement of the robot.
* `update_particle_weights_with_measurement_model()`: We will first define the sensor readings to be the `ranges` tuple from the robot's laser scan data, we will then take in the robot's laser scan data and compare the sensor readings with each particle's hypothetical sensor readings and assign a weight to each `Particle` element in the `particle_cloud` array. For now, we will use a similar measurement model provided in class 5 to compute the importance weights for each particle, with the difference that our model will have 360 computations in the denominator for each weight. To test it, we will test a few individual examples by directly printing out the weights for a few particles after a well-defined movement to see if the values match our expectations.
* `normalize_particles()` and `resample_particles()`: We will first add up all the weights of the `Particle` elements and reassign the weights by dividing each particle's original weight by that sum. We will then resample (with replacement) by creating an array of the cumulative sum of the weights, randomly generating a number, finding the index of the range that the number belong to in the cumulative array, preserve the particle at that index into the next iteration, and repeat the loop until enough particles are sampled. To test it, we will print out the weights in the normalized array to see if they add up to one, and we will also print out the array after resampling to see if more larger weights are being preserved for the next iteration and physically display the poses of the elements in the `particle_cloud` array within the map to see if they are converging to the robot's real location.
* `update_estimated_robot_pose()`: We will update the robot's estimated pose by taking an average of all the pose data in the resampled `particle_cloud` array. To test it, assuming that we have computed the above steps correctly, we will print out the estimated pose to see if it's getting closer to the robot's real location.
* Incorporating noise: For each particle movement, we will add a 5-10% buffer to the amount the robot has moved and allow the pose data to be updated to any of the values in that range. To test it, we will test a few individual examples by directly printing out the array to see if the values match our expectations as well as update the display of the `particle_cloud` array to visualize if the movement of the particles display noise when corresponded to the movement of the robot.
### Timeline
* 4/18: Complete `initialize_particle_cloud()`, `update_particles_with_motion_model()`, and `update_particle_weights_with_measurement_model()`.
* 4/21: Complete `normalize_particles()`, `resample_particles()`, and `update_estimated_robot_pose()`.
* 4/25: Add noise into the system and ensure the code works with rigorous testing.
